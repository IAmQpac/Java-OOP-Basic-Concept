package ExceptionHandling_lec5;import java.util.InputMismatchException;// ExceptionHandling4.java By: Aiman Hanna (C) 1993 - 2020// This program illustrates exception handling further. The "Exception"// class is not the only class that is used for exceptions; yet it is // the base class of all exception classes. Other exception classes are// provided by the language, and programmers can define their own // exception classes. This program illustrates how a new exception class // can be defined and used. For uniformity, programmer-defined exception // classes should always have a constructor that accepts a String type parameter, // and a method called getMessage() that returns the contents of the String // attribute of the class.//// Key Points:// 1) Programmer-defined Exception Class.// *******************************************************************import java.util.Scanner;// Define a new exception class that targets all errors in relation to // division by zeroclass DivisionByZeroException extends Exception {	private static final long serialVersionUID = 1L;	// Constructor	public DivisionByZeroException() {		// Since this class is particular for this type of errors; that is,		// division by zero, a message to that effect can be coded to that effect		super("Error ... Division by zero detected. Cannot perform division operation.");	}	// A constructor that takes a String parameter	public DivisionByZeroException(String s) {		// Allows the possibility to display any other desired exception message		super(s);	}	public String getMessage() // Does this method do much? Why or why not?	{		return super.getMessage();	}}//Define a new exception class that targets trivial division cases where the divisor //is always zero class ResultIsAlwaysZeroException extends Exception{	private static final long serialVersionUID = 1L;	// Constructor 	public ResultIsAlwaysZeroException()	{		super("Trivial Division ... Result is Always 0.");	}		// A constructor that takes a String parameter	public ResultIsAlwaysZeroException(String s)	{		// Allows the possibility to display any other desired or customized exception message 		super(s);	}		public String getMessage()	{		return super.getMessage();	}}public class ExceptionHandling4_6 {	// A method that takes two double value and return the result of their division	public static double divide_1(double x, double y) {		// This method simply does not do/handle anything about exceptions		double result = x / y;		System.out.println("\nExecuting divide_1() ...");		System.out.println("The result of dividing " + x + " by " + y + " is: " + result);		return result;	}	// A method that takes two double value and return the result of their division	public static double divide_2(double x, double y) {		// This method actually handles special cases without exception handling		// techniques.		double result;		System.out.println("\nExecuting divide_2() ...");		if (y != 0) {			result = x / y;			System.out.println("The result of dividing " + x + " by " + y + " is: " + result);			return result;		} else {			System.out.println("Cannot perform division by 0. Will return \"-0\" as an indication of error. ");			return -0;		}	}	// A method that takes two double value and return the result of their division	public static double divide_3(double x, double y) {		// This method use exception handling techniques to catch and handle		// potential errors/exceptions		double result;		System.out.println("\nExecuting divide_3() ...");		try {			if (y == 0)				throw new DivisionByZeroException();			else {				result = x / y;				System.out.println("The result of dividing " + x + " by " + y + " is: " + result);				return result;			}		} catch (DivisionByZeroException e) {			String s = e.getMessage();			System.out.println(s);			return -0;		}	}	// A method that takes two double value and return the result of their division	// This method throws an exception in case division by zero is detected	// throws means this divide_4() is problematic and when this functions is called it should be within 	// in the TRY CATCHED BLOCK	public static double divide_4(double x, double y) throws DivisionByZeroException {		double result;		System.out.println("\nExecuting divide_4() ...");		if (y == 0)			// throw new DivisionByZeroException()  //[ direct constructor calling.....]			// customized constructor calling......			throw new DivisionByZeroException("Error: Division by Zero Detected by user defined exception class; Cannot Perform Division.");		else {			result = x / y;			System.out.println("The result of dividing " + x + " by " + y + " is: " + result);			return result;		}	}		// throws multiple exceptions and in this case order of throw and catch block does not follow catching 	// and throwing order.	// but if the class follow hierarchy or inheritance then order of throwing and catching exception 	// is matter and extremely important. In that case we should follow child to parent class in the catching 	// and throwing exception. 	public static double divide_5(double x, double y) throws DivisionByZeroException, ResultIsAlwaysZeroException {		double result;		System.out.println("\nExecuting divide_5() ...");		if (y == 0)			// throw new DivisionByZeroException()  //[ direct constructor calling.....]			// customized constructor calling......			throw new DivisionByZeroException("Error: Division by Zero Detected by user defined exception class; Cannot Perform Division.");		if (x == 0)			throw new ResultIsAlwaysZeroException();		else {			result = x / y;			System.out.println("The result of dividing " + x + " by " + y + " is: " + result);			return result;		}	}		public static double checkNullPointerExp(double x, double y, ExceptionHandling4_6 e4) throws Exception, NullPointerException {		System.out.println("\nExecuting checkNullPointerExp() ...");		if(y == 0)			throw new Exception("This exception is throw by me.");		else if(e4 == null)			throw new NullPointerException("This exception is throw by me by creating null object of a java class.");		else 			return x;	}		public static double divide_6(double x, double y) throws InputMismatchException {				if(x == 0)			throw new InputMismatchException("throws InputMismatchException: Testting how it works");				return y;			}		public static void main(String[] args) {		// https://www.javatpoint.com/multiple-catch-block-in-java		Scanner kb = new Scanner(System.in);		double d1, d2;		System.out.print("Please enter two values to perform a division: ");		d1 = kb.nextDouble();		d2 = kb.nextDouble();		// Call divide_1() to perform the division		divide_1(d1, d2);		// Call divide_2() to perform the division		divide_2(d1, d2);		// Call divide_3() to perform the division		divide_3(d1, d2);		// this problematic functions can not be called without try catch block and show error		// if uncomment this functions:		// divide_4(d1, d2);				try {			divide_4(d1, d2);		} catch (DivisionByZeroException dbz) {			System.out.print(dbz.getMessage());		}				// here order does not matter and it will not show any error message by compiler but 		// for inherited exception class it important to follow order;		// here is the order of exception handling : https://www.javatpoint.com/exception-handling-in-java		// and follow child to parent order for catching the exception.		try {			divide_5(d1, d2);		}		catch (DivisionByZeroException dbz) {			System.out.println(dbz.getMessage());		}catch (ResultIsAlwaysZeroException raz) {			System.out.print(raz.getMessage()); 		} 								try {			ExceptionHandling4_6 e4 = null;			checkNullPointerExp(d1, d2, e4);		}		catch (NullPointerException np) {			System.out.println(np.getMessage());		}catch (Exception e) {			System.out.println(e.getMessage()); 		} 						try {			divide_6(d1, d2);		} catch (Exception e) {			System.out.println(e.getMessage()); 		}finally {			System.out.println("Executing the last statement"); 		}										kb.close();	}}/* * DIFFERENCE BETWEEN ERROR AND EXCEPTIONSError: An Error indicates serious problem that a reasonable application should not try to catch.Exception: Exception indicates conditions that a reasonable application might try to catch.*/